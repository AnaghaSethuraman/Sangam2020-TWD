# -*- coding: utf-8 -*-
"""Through_wall_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IoGn5hWexRiJCFiMOOiMzqvzMC1TF4Zh
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 2.x

import keras
from keras.layers import Dense, Activation
from keras.layers import Conv2D,Flatten,BatchNormalization,Dropout,MaxPooling2D
from keras.models import Sequential
from keras import utils
import numpy as np
from keras.optimizers import Adam
from sklearn.model_selection import train_test_split

import os
import math

import matplotlib.pyplot as plt
from scipy.integrate import quad
import csv
from random import randrange
import decimal

value = []
storage = []
for i in range(100):
  value.append(float(decimal.Decimal(randrange(100,700)/100)))
#print(value)
for a in value:
  def integrand(t):
      return (math.exp(-t))*t**(a-1)
  ans, err = quad(integrand, 0, np.inf)
  
  
  temp = 0
  x = 0
  y= 1

  xaxis=[]
  yaxis=[]

  with open('data.csv', 'w', newline='') as file:
      writer = csv.writer(file)
      while y >= (0.05*temp):
          y = ((x**(a-1))*(2.71**(-x)))
          writer.writerow([x, y])
          if y > temp:
              temp = y
          x = x + 0.01

  if (a <= 3):
      label = 1
  else:
      label = 0
  
  storage.append([x,y,label])

data = np.loadtxt('data.csv', delimiter =',')
frequency = data[:,0]
intensity = data[:,1]
print(storage)
#plt.plot(frequency, intensity)
#plt.plot(x,y, label='Frequency Spectrum')
#plt.xlabel('Frequency')
#plt.ylabel('Intensity')
#plt.title('Frequency Spectrum')
#plt.legend()
#plt.show()

#variables
batch_size = 32 
output_channels = 2 
input_shape = (150,2,0) 
epochs = 5

#inp = r'C:\Users\adith\OneDrive\Desktop\New folder\data.csv'
inp = storage

#here we have to assign the variables that has to be used for training
X = []
Y = []
for element in range(len(storage)):
  X.append([storage[element][0],storage[element][1]])
  Y.append(storage[element][2])
print(X)
print(Y)

#to assign the label to images
#def assign_label(x,Type):
#    return Type
 

#def training(Type,Dir):
 #   for img in os.listdir(Dir):
  #      label=assign_label(img,Type)
   #     X.append(np.array(img))
    #    y.append(str(label))
        

#training('data',inp)

#if the dataset has to be labelled then few more lines here

X = np.array(X)
print(X.shape)
from sklearn.preprocessing import LabelEncoder
from keras.utils import to_categorical
labelEncoder = LabelEncoder()
Y1 = labelEncoder.fit_transform(Y)
Y1 = to_categorical(Y1,2)

#splitting the data for training and validation
X_train, X_val, y_train, Y_val = train_test_split(X, Y1, test_size=0.2, random_state=1)
x_val, x_test, y_val, y_test = train_test_split(X_val,Y_val, test_size=0.5, random_state=1 )

#model
model = Sequential()
model.add(Conv2D(8, (2,2), padding='same', activation='relu', input_shape=(100,2,1)))#input layer
model.add(BatchNormalization(momentum = 0.9))
#model.add(MaxPooling2D(strides=(2,2)))

model.add(Conv2D(16, (2,2), padding='same', activation='relu'))
#model.add(MaxPooling2D(strides=(2,2)))

model.add(Conv2D(32, (2,2), padding='same', activation='relu'))
#model.add(MaxPooling2D(strides=(2,2)))

model.add(Conv2D(64, (2,2), padding='same', activation='relu'))
#model.add(MaxPooling2D(strides=(2,2)))

model.add(Conv2D(128, (2,2), padding='same', activation='relu'))
model.add(MaxPooling2D(strides=(2,2)))

model.add(Flatten())
model.add(Dense(128,activation = 'relu'))
model.add(Dropout(0.1))

model.add(Dense(16,activation = 'relu'))
model.add(Dense(2,activation = 'softmax'))#ouput layer

model.compile(optimizer = Adam(lr = 0.001) , loss = 'binary_crossentropy', metrics = ['accuracy'])

model.summary()
#training the data
model.fit(X_train,y_train,batch_size = batch_size ,epochs = epochs, verbose = 1,validation_data = (x_val,y_val),shuffle = True)

pred = model.predict(X_test)
prediction = np.argmax(pred,axis = 1)

y_pred =labelEncoder.fit_transform(y_test)
y_pred=to_categorical(y_pred,2)
y_pred2 = np.argmax(y_pred,axis = 1)